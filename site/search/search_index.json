{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u524d\u8a00","text":"<p>\u53c2\u8003CS\u81ea\u5b66\u6307\u5357\uff0c\u597d\u597d\u624e\u5b9e\u4e00\u4e0b\u8ba1\u7b97\u673a\u57fa\u7840\u3002\u6253\u597d\u5730\u57fa\u624d\u80fd\u5efa\u9ad8\u697c\u3002</p>"},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","title":"\u8ba1\u7b97\u673a\u7f51\u7edc","text":""},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#daolun","title":"daolun","text":""},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#h3","title":"h3","text":""},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#h2","title":"h2","text":""},{"location":"%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/#hjdkj","title":"hjdkj","text":"<p>hello</p> <pre><code>\n#include \"gtest/gtest.h\"\n#include \"gmock/gmock.h\"\n#include \"hw1.h\"\n\n/*\nTEST(HW1Test, ZEROS) {\n    Matrix matrix{algebra::zeros(5, 6)};\n\n    // check the size of the matrix\n    EXPECT_EQ(matrix.size(), 5);\n    EXPECT_EQ(matrix[0].size(), 6);\n\n    // check the value of the elements\n    for (const auto&amp; row : matrix)\n        for (const auto&amp; elem : row)\n            EXPECT_DOUBLE_EQ(elem, 0);\n}\n\nTEST(HW1Test, ONES) {\n    Matrix matrix{algebra::ones(7, 3)};\n\n    // check the size of the matrix\n    EXPECT_EQ(matrix.size(), 7);\n    EXPECT_EQ(matrix[0].size(), 3);\n\n    // check the value of the elements\n    for (const auto&amp; row : matrix)\n        for (const auto&amp; elem : row)\n            EXPECT_DOUBLE_EQ(elem, 1);\n}\n\nTEST(HW1Test, RANDOM1) {\n    using ::testing::AllOf;\n    using ::testing::Ge;\n    using ::testing::Lt;\n\n    Matrix matrix{algebra::random(4, 4, -5, 7)};\n\n    // check the size of the matrix\n    EXPECT_EQ(matrix.size(), 4);\n    EXPECT_EQ(matrix[0].size(), 4);\n\n    // check the value of the elements\n    for (const auto&amp; row : matrix)\n        for (const auto&amp; elem : row)\n            EXPECT_THAT(elem, AllOf(Ge(-5.0), Lt(7)));\n\n    // show the matrix to test algebra::show function\n    std::cout &lt;&lt; \"random matrix [-5, 7)\" &lt;&lt; std::endl;\n    algebra::show(matrix);\n    std::cout &lt;&lt; std::endl;\n}\n\nTEST(HW1Test, RANDOM2) {\n    // Caution: min cannot be greater than max\n    EXPECT_THROW(algebra::random(3, 4, 4, 2), std::logic_error);\n}\n\nTEST(HW1Test, MULTIPLY1) {\n    Matrix matrix{algebra::random(3, 4, -4, 2)};\n    Matrix mult{algebra::multiply(matrix, 3.5)};\n\n    // check the size of the matrix\n    EXPECT_EQ(mult.size(), 3);\n    EXPECT_EQ(mult[0].size(), 4);\n\n    // check the value of the elements\n    for (size_t i{}; i &lt; mult.size(); i++)\n        for (size_t j{}; j &lt; mult[i].size(); j++)\n            EXPECT_NEAR(mult[i][j], matrix[i][j]*3.5, 0.03);\n}\n\nTEST(HW1Test, MULTIPLY2) {\n    // Caution: multiplication of 2 empty matrix\n    Matrix matrix{algebra::multiply(Matrix{}, Matrix{})};\n    EXPECT_TRUE(matrix.empty());\n\n    // Caution: matrices with wrong dimensions cannot be multiplied\n    EXPECT_THROW(algebra::multiply(Matrix{{1, 2, 3}, {4, 5, 6}}, Matrix{{1, 2, 3}, {4, 5, 6}}), std::logic_error);\n}\n\nTEST(HW1Test, MULTIPLY3) {\n    Matrix matrix1{{-3, 3, 1.7}, {4, -4, 2.6}, {-5, 5, 3.5}};\n    Matrix matrix2{{2.5}, {-2}, {-5.5}};\n    Matrix matrix{algebra::multiply(matrix1, matrix2)};\n\n    // check the size of the matrix\n    EXPECT_EQ(matrix.size(), 3);\n    EXPECT_EQ(matrix[0].size(), 1);\n\n    // check the value of the elements\n    EXPECT_NEAR(matrix[0][0], -22.85, 0.03);\n    EXPECT_NEAR(matrix[1][0], 3.7, 0.03);\n    EXPECT_NEAR(matrix[2][0], -41.75, 0.03);\n}\n\nTEST(HW1Test, MULTIPLY4) {\n    Matrix matrix1{{-3, 2, 1.7}, {4, -5, 2.6}, {7.2, 5, 3.5}};\n    Matrix matrix2{{6.5}, {-2}, {-5}};\n    Matrix matrix{algebra::multiply(matrix1, matrix2)};\n\n    // check the size of the matrix\n    EXPECT_EQ(matrix.size(), 3);\n    EXPECT_EQ(matrix[0].size(), 1);\n\n    // check the value of the elements\n    EXPECT_NEAR(matrix[0][0], -32, 0.03);\n    EXPECT_NEAR(matrix[1][0], 23, 0.03);\n    EXPECT_NEAR(matrix[2][0], 19.3, 0.03);\n}\n\nTEST(HW1Test, SUM1) {\n    // Caution: sum of an empty matrix\n    EXPECT_TRUE(algebra::sum(Matrix{}, 1.5).empty());\n\n    Matrix matrix{algebra::random(2, 5, 0, 4)};\n    Matrix sum{algebra::sum(matrix, 2.44)};\n\n    // check the size of the matrix\n    EXPECT_EQ(sum.size(), 2);\n    EXPECT_EQ(sum[0].size(), 5);\n\n    // check the value of the elements\n    for (size_t i{}; i &lt; sum.size(); i++)\n        for (size_t j{}; j &lt; sum[i].size(); j++)\n            EXPECT_NEAR(sum[i][j], matrix[i][j]+2.44, 0.03);\n}\n\nTEST(HW1Test, SUM2) {\n    // Caution: sum of 2 empty matrices\n    EXPECT_TRUE(algebra::sum(Matrix{}, Matrix{}).empty());\n\n    // Caution: matrices with wrong dimensions cannot be summed\n    EXPECT_THROW(algebra::sum(Matrix{{1, 2, 3}}, Matrix{}), std::logic_error);\n\n    Matrix matrix1{algebra::random(3, 2, -1, 4)};\n    Matrix matrix2{algebra::random(3, 2, -8, -3)};\n    Matrix sum{algebra::sum(matrix1, matrix2)};\n\n    // check the size of the matrix\n    EXPECT_EQ(sum.size(), 3);\n    EXPECT_EQ(sum[0].size(), 2);\n\n    // check the value of the elements\n    for (size_t i{}; i &lt; sum.size(); i++)\n        for (size_t j{}; j &lt; sum[i].size(); j++)\n            EXPECT_NEAR(sum[i][j], matrix1[i][j]+matrix2[i][j], 0.03);\n}\n\nTEST(HW1Test, TRANSPOSE) {\n    // Caution: transpose of an empty matrix is an empty matrix\n    EXPECT_TRUE(algebra::transpose(Matrix{}).empty());\n\n    Matrix matrix{algebra::random(3, 5, -2, 5)};\n    Matrix transpose = algebra::transpose(matrix);\n\n    // check the size of the matrix\n    EXPECT_EQ(transpose.size(), 5);\n    EXPECT_EQ(transpose[0].size(), 3);\n\n    // check the value of the elements\n    for (size_t i{}; i &lt; transpose.size(); i++)\n        for (size_t j{}; j &lt; transpose[i].size(); j++)\n            EXPECT_DOUBLE_EQ(transpose[i][j], matrix[j][i]);\n}\n\nTEST(HW1Test, MINOR1) {\n    Matrix matrix{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    Matrix minor = algebra::minor(matrix, 1, 2);\n\n    // check the size of the matrix\n    EXPECT_EQ(minor.size(), 2);\n    EXPECT_EQ(minor[0].size(), 2);\n\n    // check the value of the elements\n    EXPECT_DOUBLE_EQ(minor[0][0], matrix[0][0]);\n    EXPECT_DOUBLE_EQ(minor[0][1], matrix[0][1]);\n    EXPECT_DOUBLE_EQ(minor[1][0], matrix[2][0]);\n    EXPECT_DOUBLE_EQ(minor[1][1], matrix[2][1]);\n}\n\nTEST(HW1Test, MINOR2) {\n    Matrix matrix{{7, 2.5, 3.1}, {4.2, 5, 10.4}, {70.7, 8, 0}};\n    Matrix minor = algebra::minor(matrix, 1, 1);\n\n    // check the size of the matrix\n    EXPECT_EQ(minor.size(), 2);\n    EXPECT_EQ(minor[0].size(), 2);\n\n    // check the value of the elements\n    EXPECT_DOUBLE_EQ(minor[0][0], matrix[0][0]);\n    EXPECT_DOUBLE_EQ(minor[0][1], matrix[0][2]);\n    EXPECT_DOUBLE_EQ(minor[1][0], matrix[2][0]);\n    EXPECT_DOUBLE_EQ(minor[1][1], matrix[2][2]);\n}\n\nTEST(HW1Test, DETERMINANT1) {\n    // Caution: determinant of an empty matrix\n    EXPECT_EQ(algebra::determinant(Matrix{}), 1);\n\n    // Caution: non-square matrices have no determinant\n    EXPECT_THROW(algebra::determinant(Matrix{{1, 2, 3}, {4, 5, 6}}), std::logic_error);\n\n    // test case\n    Matrix matrix{{-1, 1.5, -1.75, -2}, {-2, 2.5, -2.75, -3}, {3, 3.5, -3.75, -4}, {4, 4.5, 4.75, -5}};\n    EXPECT_NEAR(algebra::determinant(matrix), -28.5, 0.03);\n}\n\nTEST(HW1Test, DETERMINANT2) {\n    // test case\n    Matrix matrix{{1, 1.5, -1.75, 2}, {2, 2.5, -2.75, 3}, {3, 3.5, -3.75, 4}, {4, 4.5, 4.75, 5}};\n    EXPECT_DOUBLE_EQ(algebra::determinant(matrix), 0);\n}\n\nTEST(HW1Test, INVERSE1) {\n    // Caution: inverse of an empty matrix\n    EXPECT_TRUE(algebra::inverse(Matrix{}).empty());\n\n    // Caution: non-square matrices have no inverse\n    EXPECT_THROW(algebra::inverse(Matrix{{1, 2, 3}, {40, 5, -6}}), std::logic_error);\n\n    // Caution: singular matrices have no inverse\n    Matrix non_singular_matrix{{1, 1.5, -1.75, 2}, {2, 2.5, -2.75, 3}, {3, 3.5, -3.75, 4}, {4, 4.5, 4.75, 5}};\n    EXPECT_THROW(algebra::inverse(non_singular_matrix), std::logic_error);\n\n    // test case\n    Matrix matrix{{-1, 1.5, -1.75, -2}, {-2, 2.5, -2.75, -3}, {3, 3.5, -3.75, -4}, {4, 4.5, 4.75, -5}};\n    Matrix inverse{algebra::inverse(matrix)};\n    EXPECT_NEAR(inverse[0][0], 0.16, 0.03);\n    EXPECT_NEAR(inverse[1][1], 3.31, 0.03);\n    EXPECT_NEAR(inverse[3][1], 2.67, 0.03);\n    EXPECT_NEAR(inverse[0][3], 0, 0.03);\n}\n\n\nTEST(HW1Test, INVERSE2) {\n    // test case\n    Matrix matrix{{-12, 1.5, -1.75, -2}, {-2, 2.5, -2.75, -3}, {25, 3.5, -3.75, -4}, {4, 4.5, 4.75, -51}};\n    Matrix inverse{algebra::inverse(matrix)};\n    EXPECT_NEAR(inverse[0][0], 0.05, 0.03);\n    EXPECT_NEAR(inverse[1][1], 18.07, 0.03);\n    EXPECT_NEAR(inverse[3][1], 2.80, 0.03);\n    EXPECT_NEAR(inverse[0][3], 0, 0.03);\n}\n\nTEST(HW1Test, CONCATENATE1) {\n    // Caution: matrices with wrong dimensions cannot be concatenated\n    EXPECT_THROW(algebra::concatenate(Matrix{{1, 2}}, Matrix{{1, 2, 3}, {4, 5, 6}}, 0), std::logic_error);\n\n    // test case\n    Matrix matrix1{algebra::random(2, 3, 0, 1)};\n    Matrix matrix2{algebra::random(4, 3, 0, 1)};\n    Matrix matrix{algebra::concatenate(matrix1, matrix2, 0)};\n\n    // check the size of the matrix\n    EXPECT_EQ(matrix.size(), 6);\n    EXPECT_EQ(matrix[0].size(), 3);\n\n    // check the value of the elements\n    EXPECT_DOUBLE_EQ(matrix[0][0], matrix1[0][0]);\n    EXPECT_DOUBLE_EQ(matrix[1][2], matrix1[1][2]);\n    EXPECT_DOUBLE_EQ(matrix[2][0], matrix2[0][0]);\n    EXPECT_DOUBLE_EQ(matrix[5][2], matrix2[3][2]);\n\n}\n\nTEST(HW1Test, CONCATENATE2) {\n    // Caution: matrices with wrong dimensions cannot be concatenated\n    EXPECT_THROW(algebra::concatenate(Matrix{{1, 2}}, Matrix{{1, 2, 3}, {4, 5, 6}}, 1), std::logic_error);\n\n    // test case\n    Matrix matrix1{algebra::random(2, 3, 0, 1)};\n    Matrix matrix2{algebra::random(2, 1, 0, 1)};\n    Matrix matrix{algebra::concatenate(matrix1, matrix2, 1)};\n\n    // check the size of the matrix\n    EXPECT_EQ(matrix.size(), 2);\n    EXPECT_EQ(matrix[0].size(), 4);\n\n    // check the value of the elements\n    EXPECT_DOUBLE_EQ(matrix[0][0], matrix1[0][0]);\n    EXPECT_DOUBLE_EQ(matrix[1][2], matrix1[1][2]);\n    EXPECT_DOUBLE_EQ(matrix[0][3], matrix2[0][0]);\n    EXPECT_DOUBLE_EQ(matrix[1][3], matrix2[1][0]);\n}\n\nTEST(HW1Test, ERO_SWAP) {\n    // Caution: r1 or r2 inputs are out of range\n    EXPECT_THROW(algebra::ero_swap(Matrix{{1, 2}}, 0, 1), std::logic_error);\n\n    // test case\n    Matrix matrix{algebra::random(4, 3, 0, 4)};\n    Matrix swap{algebra::ero_swap(matrix, 2, 3)};\n\n    // check the swap\n    EXPECT_TRUE(swap[0] == matrix[0]);\n    EXPECT_TRUE(swap[1] == matrix[1]);\n    EXPECT_TRUE(swap[2] == matrix[3]);\n    EXPECT_TRUE(swap[3] == matrix[2]);\n}\n\nTEST(HW1Test, ERO_MULTIPLY) {\n    Matrix matrix{algebra::random(4, 3, 0, 4)};\n    Matrix ero{algebra::ero_multiply(matrix, 2, 1.5)};\n\n    EXPECT_TRUE(ero[0] == matrix[0]);\n    EXPECT_TRUE(ero[1] == matrix[1]);\n    EXPECT_TRUE(ero[3] == matrix[3]);\n\n    // check the value of the elements\n    for (size_t i{}; i &lt; ero[2].size(); i++)\n        EXPECT_NEAR(ero[2][i], matrix[2][i]*1.5, 0.03);\n}\n\nTEST(HW1Test, ERO_SUM) {\n    Matrix matrix{algebra::random(4, 3, 0, 4)};\n    Matrix ero{algebra::ero_sum(matrix, 0, 2, 3)};\n\n    EXPECT_TRUE(ero[0] == matrix[0]);\n    EXPECT_TRUE(ero[1] == matrix[1]);\n    EXPECT_TRUE(ero[2] == matrix[2]);\n\n    // check the value of the elements\n    for (size_t i{}; i &lt; ero[3].size(); i++)\n        EXPECT_NEAR(ero[3][i], matrix[0][i]*2+matrix[3][i], 0.03);\n}\n\nTEST(HW1Test, UPPER_TRIANGULAR1) {\n    // Caution: empty matrix\n    EXPECT_TRUE(algebra::upper_triangular(Matrix{}).empty());\n\n    // Caution: non-square matrices have no upper triangular form\n    EXPECT_THROW(algebra::upper_triangular(Matrix{{1, 2, 3}, {4, 5, 6}}), std::logic_error);\n\n    // test case 1\n    Matrix matrix1{{1, 2}, {5, 7}};\n    Matrix res1{algebra::upper_triangular(matrix1)};\n    EXPECT_NEAR(res1[0][0], 1, 0.03);\n    EXPECT_NEAR(res1[1][0], 0, 0.03);\n    EXPECT_NEAR(res1[1][1], -3, 0.03);\n\n    // test case 2\n    Matrix matrix2{{1, 2, 3}, {4, 7, 5}, {6, 1, 3}};\n    Matrix res2{algebra::upper_triangular(matrix2)};\n    EXPECT_NEAR(res2[0][0], 1, 0.03);\n    EXPECT_NEAR(res2[1][0], 0, 0.03);\n    EXPECT_NEAR(res2[2][0], 0, 0.03);\n    EXPECT_NEAR(res2[2][1], 0, 0.03);\n    EXPECT_NEAR(res2[2][2], 62, 0.03);\n}\n\nTEST(HW1Test, BONUS) {\n    // test case\n    Matrix matrix2{{0, 2, 3}, {4, 7, 5}, {6, 1, 3}};\n    Matrix res2{algebra::upper_triangular(matrix2)};\n    EXPECT_NEAR(res2[0][0], 4, 0.03);\n    EXPECT_NEAR(res2[1][0], 0, 0.03);\n    EXPECT_NEAR(res2[2][0], 0, 0.03);\n    EXPECT_NEAR(res2[2][1], 0, 0.03);\n    EXPECT_NEAR(res2[2][2], 39/4.0, 0.03);\n}\n*/\n\n</code></pre>"}]}